# Задание 11

## Решение

### Уровень классов

Класс слишком большой

- получается, когда продолжительное время добавляют функционал мелкими порциями
  - часто это различные условия и соответствующая логика
- также божественным со временем становится класс, содержащий константы и другую статику

В программе создаётся слишком много инстансов класса

- может быть актуально в играх, где есть типовой юнит и он нужен в разных местах с различным набором аттрибутов

Класс слишком маленький или делает слишком мало

- может быть при функциональном подходе к программированию
- может получиться при попытке развязать узел и провести декомпозицию

В классе есть метод, который выглядит более подходящим для другого класса

- ошибки проектирования или именования
  - иногда может содержать корректный функционал, но название метода может быть двусмысленным и содержать ссылку на
    имя другого класса

Класс хранит данные, которые загоняются в него в множестве разных мест в программе

- классический случай "помойного" класса, где сложены все константы и статика проекта

Класс зависит от деталей реализации других классов

- типовой случай сильной связанности и ошибок проектирования, когда делались попытки распилить монолит

Приведение типов вниз по иерархии (родительские классы приводятся к дочерним)

- часто применяется в фабриках, без кастинга здесь, к сожалению, почти не обойтись

Когда создаётся класс-наследник для какого-то класса, приходится создавать классы-наследники и для некоторых других
классов

- предположу, что так может выглядеть попытка реализации множественного наследования в языках, где это запрещено (Java)

Дочерние классы не используют методы и атрибуты родительских классов, или переопределяют родительские методы

- попытка унификации и/или выделения абстракции с ошибками в проектировании

### Уровень приложения

Одна модификация требует внесения изменений в несколько классов

- этим страдают чаще всего микросервисы, где поначалу вроде как всё просто, а затем, с ростом требований, снежный ком
  разрастается и рефакторить становится всё сложнее и сложнее, поэтому жертвуют до определённого момента основными
  принципами проектирования, а затем переписывают/разделяют функционал

Использование сложных паттернов проектирования там, где можно использовать более простой и незамысловатый дизайн

- бич, включая меня, в попытках проявить свою крутость, а, по факту, от незнания правил применения паттернов, ведь они
  служат для решения конкретных проблем, о которых редко кто когда осведомляется и просто заучивает подход к дизайну
  паттерна без осмысления его сути и причин появления
