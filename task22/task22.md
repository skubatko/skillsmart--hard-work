# Задание 22

## Отчёт

### 1. Зависимость фреймворка

Примером может служить механизм трассировки. Механизм позволяет проследить за прохождением запроса пользователя через
задействованные модули системы. При этом сам механизм не зависит от реализации системы. Благодаря Spring AOP в заголовок
запроса добавляется информация с идентификатором запроса, что позволяет в последствии отследить маршрут прохождения
запроса.

Решение сознательное.

### 2. Зависимость расшаренного формата

Регулярно сталкивались с проблемой согласования API между фронтом и бэком. В итоге пришли к контрактной системе
взаимодействия через спецификацию OpenAPI. Теперь API контрактуется фронтом и оформляется в виде YAML файла. Далее при
помощи генератора формируется заготовка для бэка, и затем уже пишется реализация.

Решение было осознанным, был проведён анализ проблемы и возможных решений.

### 3. Зависимость зависимости

Использовали библиотеку общего функционала соседней команды. Однажды перейдя на очередную новую версию этой библиотеки
столкнулись с тем, что наш проект перестал собираться. Проблема оказалась в зависимости от версии Swagger. У нас
использовалась версия 2.0, а у соседей 3.0. В итоге они конфликтовали между собой. Пришлось перейти на новую версию
Swagger и нам.

Решение было сознательным.

### 4. Зависимость краша

Также был пример, когда соседняя команда доработала функционал, мы обновились на новую версию их библиотеки и у нас
деградировал наш сервис на ПРОДе, о чём мы узнали от наших потребителей. По итогам изысканий выяснилось, что коллеги
обновили систему трассировки, которая со временем забивала память. В итоге пришлось откатиться на предыдущую версию.

Решение было сознательным.

### 5. Зависимость перебрасывания

При разработке интеграции со сторонними сервисами по REST часто возникает необходимость сделать заглушку, например, при
помощи Wiremock. Таким образом имеем две реализации интеграции: боевую и фейковую. Переключение на заглушку происходит
при отсутствии доступа к боевому сервису.

Сделано это сознательно.

### 6. Зависимость инверсии

Долго спорили всегда ли нужно писать на интерфейсах в Spring. В итоге пришли к соглашению, что если не предполагается в
настоящий момент возможность нескольких реализаций, интерфейсы не применяем. Выделить интерфейс легко можно при
необходимости. Хотя при написании тестов это иногда мешает.

Решение было сознательным.

### 7. Зависимость зацикливания

В начале использования Spring Boot частенько натыкался на ситуацию, когда приложение не стартовало, ходя код компилился
нормально и вроде по логике всё было норм. Дело было в циклических зависимостях. Когда один бин зависит от другого,
тот - от третьего и так далее. В итоге цепочка могла быть длиной в десяток бинов, где последний ссылался в итоге на
первый. В результате Spring не мог собрать бины. Выявить такую ситуацию на этапе кодирования достаточно проблематично.
Теперь стараюсь следовать правилу, когда один бин не должен содержать более трёх зависимостей на другие бины. Это
помогает предотвратить описанную ситуацию.

Решение осознанное.

### 8. Зависимость высшего порядка

Пример со Spring Data JPA. При реализации своего репозитория легко можно подменить стандартную логику Spring. В итоге
будет вызван наш функционал стандартной библиотекой Spring.

Сделано это сознательно.

### 9. Зависимость большинства

У нас в команде пять разработчиков. Каждый со своим уровнем знаний и подходом к программированию. Мы договорились о
неких общих правилах, что позволило всем пятерым вести разработку почти безболезненно. Конечно, пришлось поступиться
некими своими принципами, но это позволило коллегам понимать достаточно быстро чужой код, что важно при сжатых сроках
разработки.

Решение было осознанным.
