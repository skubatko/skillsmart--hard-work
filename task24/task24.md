# Задание 24

## Отчёт

### 1. Зависимость фреймворка

Механизм трассировки. Механизм позволяет проследить за прохождением запроса пользователя через
задействованные модули системы. При этом сам механизм не зависит от реализации системы.

Поведение механизма трассировки зависит от запросов пользователей во время работы трассировки.

### 2. Зависимость расшаренного формата

Проблема согласования API между фронтом и бэком.

Контрактная системе взаимодействия через спецификацию OpenAPI. Фронт и бэк таким образом не зависят друг от друга, хотя
и связаны между собой.

### 3. Зависимость зависимости

Использовали библиотеку общего функционала соседней команды. Однажды перейдя на очередную новую версию этой библиотеки
столкнулись с тем, что наш проект перестал собираться. Проблема оказалась в зависимости от версии Swagger. У нас
использовалась версия 2.0, а у соседей 3.0. В итоге они конфликтовали между собой.

Договорились фиксировать версии используемых библиотек между командами.

### 4. Зависимость краша

Соседняя команда доработала функционал, мы обновились на новую версию их библиотеки и у нас
деградировал наш сервис на ПРОДе, о чём мы узнали от наших потребителей. По итогам изысканий выяснилось, что коллеги
обновили систему трассировки, которая со временем забивала память.

Договорились фиксировать версии используемых библиотек у себя.

### 5. Зависимость перебрасывания

При разработке интеграции со сторонними сервисами по REST часто возникает необходимость сделать заглушку, например, при
помощи Wiremock. Таким образом имеем две реализации интеграции: боевую и фейковую. Переключение на заглушку происходит
при отсутствии доступа к боевому сервису.

Сделали настройки в конфиги, можно контролировать переключение.

### 6. Зависимость инверсии

Долго спорили всегда ли нужно писать на интерфейсах в Spring. В итоге пришли к соглашению, что если не предполагается в
настоящий момент возможность нескольких реализаций, интерфейсы не применяем. Выделить интерфейс легко можно при
необходимости. Хотя при написании тестов это иногда мешает.

### 7. Зависимость зацикливания

В начале использования Spring Boot частенько натыкался на ситуацию, когда приложение не стартовало, ходя код компилился
нормально и вроде по логике всё было норм. Дело было в циклических зависимостях. Когда один бин зависит от другого,
тот - от третьего и так далее. В итоге цепочка могла быть длиной в десяток бинов, где последний ссылался в итоге на
первый. В результате Spring не мог собрать бины. Выявить такую ситуацию на этапе кодирования достаточно проблематично.

Следуем правилу, когда один бин не должен содержать более трёх зависимостей на другие бины. Это помогает предотвратить
возможные циклические зависимости.

### 8. Зависимость высшего порядка

Пример со Spring Data JPA. При реализации своего репозитория легко можно подменить стандартную логику Spring. В итоге
будет вызван наш функционал стандартной библиотекой Spring.

Делать это нужно строго в соответствии со спецификацией Spring.

### 9. Зависимость большинства

У нас в команде пять разработчиков. Каждый со своим уровнем знаний и подходом к программированию. Возникают постоянно
конфликты форматирования кода и страдает удобство чтения кода.

Мы договорились о неких общих правилах, что позволило всем пятерым вести разработку почти безболезненно. Конечно,
пришлось поступиться некими своими принципами, но это позволило коллегам понимать достаточно быстро чужой код, что важно
при сжатых сроках разработки.
