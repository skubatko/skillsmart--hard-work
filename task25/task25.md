# Задание 25

## Решение

- [case1](case1)
- [case2](case2)
- [case3](case3)

## Отчёт

### case1

Изначально был реализован робот очистки устаревших данных Spring Batch с применением стандартного механизма Spring Data
JPA, который под капотом использует ORM Hibernate.

Очистка вешала периодически СУБД, и пользователи жаловались на перебои в работе сервиса.

В итоге отказались от использования стандартного механизма и решили использовать JdbcTemplate, при помощи которого был
написан новый робот. Новая реализация использовала нативные SQL-запросы. Данная реализация предотвращала блокирование
БД, а также позволила снизить нагрузку на БД путём чанкования выборки для чистки.

Таким образом, было сведено к минимуму влияние процесса очистки БД на пользователей.

### case2

Изначально поиск заявок был реализован при помощи стандартных механизмов Spring Boot, которые подразумевают применение
ORM Hibernate.

После неоднократных жалоб пользователей на продолжительное ожидание ответа сервиса при оформлении кредита было принято
решение переписать выборку данных при помощи JPQL, что близко по смыслу SQL-запросам.

В итоге добились приемлемого отклика интерфейса для пользователей.

### case3

Коллеги пользователи иногда жаловались на долгий поиск и обновление словарей.

После анализа было сделано предположение, что механизм Spring Data выполняет лишние запросы в БД при поиске и обновлении
данных словарей в БД.

Написали кастомные запросы, что решило проблему N+1 и значительно ускорило работу сервиса.
